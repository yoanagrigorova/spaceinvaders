class Resolver {
  constructor(sequence) {
    this.promises = [];
    this.count = 0;
    this.countTo = 0;
    this.returnArgs = [];
    this._sequence = sequence;
    this.index = 0;
    this.functs = [];

    this.promise = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }

  _init(...functs) {
    functs.forEach((funct) => {
      this.wrap(funct);
    });
  }

  start() {
    if (!this._sequence)
      throw new Error('You can only start a sequence.');

    this._next();
  }

  _next() {
    let promise = new Promise((resolve) => {
      this.functs[this.index++]((...args) => {
        this._resolve(...args);
        resolve();
      });
    });
    this.promises.push(promise);
  }

  _resolve(...args) {
    if (args.length > 0)
      this.returnArgs = args;

    if (++this.count >= this.countTo) {
      this.resolve(this.returnArgs);
      //console.log('done');
    } else {
      if (this._sequence)
        this._next();
    }
  }

  async wrap(funct) {
    this.countTo++;
    this.functs.push(funct);

    if (!this._sequence) {
      let promise = new Promise((resolve) => {
        funct((...args) => { // Resolve function, binds to this instance
          this._resolve(...args);
          resolve();
        });
      });
      this.promises.push(promise);
    }
  }
  
  static async async(...functs) {
    let resolver = new Resolver(false);
    resolver._init(...functs);

    return resolver.promise;
  }

  static async sequence(...functs) {
    let resolver = new Resolver(true);
    resolver._init(...functs);
    resolver.start();

    return resolver.promise;
  }

  static async series(...functs) {
    return this.sequence(...functs);
  }
}

module.exports = Resolver;